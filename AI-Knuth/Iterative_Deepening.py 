# IMPORTS
import sys  # import system library
from time import process_time  # import time library
import BigNumber  # import BigNumber module
from BigNumber.BigNumber import factorial, sqrt  # import BigNumber functions

LIMIT = 7
# Global Varialables
START_POINT = "4.0"

# CHANGE THIS NUMBER
END_POINT = BigNumber.BigNumber.BigNumber("5")

# Large random number, set by creator.
MAX_POINT = BigNumber.BigNumber.BigNumber("690000000000000")

ROOT = "root"
FACTORIAL = "factorial"
FLOOR = "floor"

RUNTIME = 60.0
# Limit: one CPU mitune
STOP = process_time() + RUNTIME
# process_time - It does not include the waiting time for resources

# bathos 18


class Tree():
    def __init__(self, node, parent, process):
        self.node = node
        self.children = []
        self.parent = parent
        self.process = process

    def printTree(self):
        print(self.node)
        for i in range(len(self.children)):
            self.children[i].printTree()


def check(currNode, visited):
    for i in visited:
        if currNode == i.node:
            return False
    return True


def ibfs(queue, root, limit):  # function for BFS
    queue.append(root)
    visited = []

    currN = root
    while queue and limit >= 0:

        node = None
        currNode = queue.pop(0)

        bigNode = BigNumber.BigNumber.BigNumber(
            currNode.node)  # New node for checking

        if (bigNode == END_POINT):  # Number found.
            return currNode

        if (process_time() > STOP or limit == 0):  # Timeout
            return False

        if (MAX_POINT > bigNode):
            try:
                # check if the bigNumber > MAX_POINT.
                # try to create the new BigNumber.
                newNode = BigNumber.BigNumber.BigNumber(factorial(bigNode))

                node = Tree(str(newNode), currNode, "with " + FACTORIAL)
            except:
                newNode = sqrt(bigNode)  # Root of node
                newNode = newNode.__floor__()  # and floor of node in the same time
                newNode = str(newNode)
                node = Tree(str(newNode), currNode,
                            "with " + ROOT + " and " + FLOOR)
        else:
            newNode = sqrt(bigNode)  # Root of node
            newNode = newNode.__floor__()  # and floor of node in the same time
            newNode = str(newNode)
            node = Tree(str(newNode), currNode,
                        "with " + ROOT + " and " + FLOOR)

        queue.append(node)

        newNode = sqrt(bigNode)  # Root of node
        newNode = newNode.__floor__()  # and floor of node in the same time
        newNode = str(newNode)
        node = Tree(str(newNode), currNode, ROOT + " " + FLOOR)

        queue.append(node)

        maxLimit = maxLimit - 1
    return False


# -------------Main-------------
# Initialize varialables

root = Tree(START_POINT, None, "")  # Create Tree

for i in range(LIMIT+1):

    depth = 0
    queue = []  # Initialize a queue

    found = ibfs(queue, root, i)
    if found.__class__ == Tree:
        depth = i
        resultTime = str(process_time() - (STOP - RUNTIME))
        break

if found.__class__ == Tree:
    solutionTree = []
    while found != None:
        solutionTree.insert(0, found)
        found = found.parent

    print(solutionTree[0].node, " ->")
    for i in range(1, len(solutionTree)):
        print(solutionTree[i].process, " ", solutionTree[i].node)

    print(resultTime[:6])

    # Add solution in file
    f = open("solution2.txt", "w")
    f.write(solutionTree[0].node + " ->\n")
    for i in range(1, len(solutionTree)):
        f.write(solutionTree[i].process + " " + solutionTree[i].node+"\n")
    f.write(resultTime[:6] + " seconds"+"\n")
    f.write("Find in depth: " + str(depth) + "\n")
    f.close()
else:
    if depth == LIMIT:
        print("telos dentroy")
